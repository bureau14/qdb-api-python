# Note this only happens when you manually set
# CMAKE_BUILD_TYPE at cmake invocation time.
# This is the case when building release packages on buildbot
IF(CMAKE_BUILD_TYPE STREQUAL Release)

  # library name and location of the dll for the python setup script
  SET(QDB_API_NAME "qdb_api")
  SET(QDB_PY_IMPL ${CMAKE_CURRENT_SOURCE_DIR}/impl.py)
  SET(QDB_PY_INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/__init__.py)
  SET(QDB_PY_WRAPPER qdb_python_wrapper.cxx)

  get_target_property(QDB_API_DLL qdb_api LOCATION_Release)

  # Get TBB libraries paths
  STRING(TOLOWER ${CMAKE_SYSTEM_NAME} PY_PACKAGE_SOURCE_SUFFIX)

  IF(MSVC)
    SET(TBB_SHARED ${Tbb_DLL_FULL_PATH})
    SET(TBB_MALLOC_SHARED ${Tbb_DLL_MALLOC_FULL_PATH})
    SET(TBB_MALLOC_PROXY_SHARED ${Tbb_DLL_MALLOC_PROXY_FULL_PATH})
    SET(ACTUAL_LIBRARY_PATH ${LIBRARY_OUTPUT_PATH}/${CMAKE_BUILD_TYPE})
    SET(QDB_CPP_LIBS ${VC110_INSTALL_LIBS})
    # a hack to avoid double export definition because we already set "dllexport" in the source code generated by SWIG
    # except when STATIC_LINKED is set
    SET(QDB_PYTHON_COMPILE_FLAG /DSTATIC_LINKED /EHsc)
  ELSE(MSVC)
    SET(TBB_SHARED ${ACTUAL_Tbb_LIBRARY_RELEASE})
    SET(TBB_MALLOC_SHARED ${ACTUAL_Tbb_MALLOC_LIBRARY_RELEASE})
    SET(TBB_MALLOC_PROXY_SHARED ${ACTUAL_Tbb_MALLOC_PROXY_LIBRARY_RELEASE})
    SET(QDB_CPP_LIBS ${GCC_ADDITIONAL_LIBS})
    SET(ACTUAL_LIBRARY_PATH ${LIBRARY_OUTPUT_PATH})
    SET(QDB_PYTHON_COMPILE_FLAG -std=c++0x)
  ENDIF(MSVC)

  # generate setup script by replacing CMake variables
  configure_file(prepare_orig.py
                 ${CMAKE_CURRENT_SOURCE_DIR}/prepare.py
                 @ONLY)

  configure_file(setup_orig.py
                 ${CMAKE_CURRENT_SOURCE_DIR}/setup.py
                 @ONLY)

  # copy readme.txt
  configure_file(${README_TXT_FILE} ${CMAKE_CURRENT_SOURCE_DIR} COPYONLY)

  IF(MSVC)
  # SWIG wrapper
    add_custom_target(
      qdb_python_api ALL
      ${SWIG_EXECUTABLE} -c++ -python -o ${QDB_PY_WRAPPER} -outdir ${CMAKE_CURRENT_SOURCE_DIR} -O -module impl -interface _qdb qdb_python_windows.i
      DEPENDS qdb_api qdb_python_windows.i
      SOURCES qdb_python_windows.i __init__.py
      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
  ELSE(MSVC)
    add_custom_target(
      qdb_python_api ALL
      ${SWIG_EXECUTABLE} -c++ -python -o ${QDB_PY_WRAPPER} -outdir ${CMAKE_CURRENT_SOURCE_DIR} -O -module impl -interface _qdb qdb_python_unix.i
      DEPENDS qdb_api qdb_python_unix.i
      SOURCES qdb_python_unix.i __init__.py
      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
  ENDIF(MSVC)

    

  set_target_properties(qdb_python_api PROPERTIES FOLDER ${CLIENT_API_IDE_FOLDER})

  add_custom_command(
       TARGET qdb_python_api
       COMMAND ${PYTHON_EXECUTABLE} prepare.py
       WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
       DEPENDS ${QDB_PY_INTERFACE} ${QDB_PY_IMPL} ${QDB_PY_WRAPPER}
       POST_BUILD)

  IF(MSVC)
    add_custom_command(
       TARGET qdb_python_api
       COMMAND ${PYTHON_EXECUTABLE} setup.py bdist_wininst
       WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
       DEPENDS ${QDB_PY_INTERFACE} ${QDB_PY_IMPL} ${QDB_PY_WRAPPER}
       POST_BUILD)
  ENDIF(MSVC)

  # dist file
  add_custom_command(
   TARGET qdb_python_api
   COMMAND ${PYTHON_EXECUTABLE} setup.py sdist
   WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
   DEPENDS ${QDB_PY_INTERFACE} ${QDB_PY_IMPL} ${QDB_PY_WRAPPER}
   POST_BUILD)

ENDIF()
