"""
QuasarDB Official Python API
"""

from __future__ import annotations

import datetime
import typing

import numpy
import numpy.ma

from . import metrics

__all__ = [
    "AliasAlreadyExistsError",
    "AliasNotFoundError",
    "AsyncPipelineFullError",
    "Blob",
    "Cluster",
    "ColumnInfo",
    "ColumnType",
    "DirectBlob",
    "DirectInteger",
    "Double",
    "Entry",
    "Error",
    "ExpirableEntry",
    "FindQuery",
    "IncompatibleTypeError",
    "IndexedColumnInfo",
    "InputBufferTooSmallError",
    "Integer",
    "InternalLocalError",
    "InvalidArgumentError",
    "InvalidDatetimeError",
    "InvalidHandleError",
    "InvalidQueryError",
    "MaskedArray",
    "Node",
    "NotImplementedError",
    "Options",
    "OutOfBoundsError",
    "Perf",
    "Properties",
    "QueryContinuous",
    "Reader",
    "RetryOptions",
    "String",
    "Table",
    "Tag",
    "Timestamp",
    "TryAgainError",
    "UninitializedError",
    "Writer",
    "WriterData",
    "WriterPushMode",
    "build",
    "dict_query",
    "metrics",
    "never_expires",
    "version",
]

class AliasAlreadyExistsError(Error):
    pass

class AliasNotFoundError(Error):
    pass

class AsyncPipelineFullError(Error):
    pass

class Blob(ExpirableEntry):
    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def compare_and_swap(self, new_content: str, comparand: str) -> bytes: ...
    def get(self) -> bytes: ...
    def get_and_remove(self) -> bytes: ...
    def get_and_update(self, data: str) -> bytes: ...
    def put(self, data: str) -> None: ...
    def remove_if(self, comparand: str) -> None: ...
    def update(self, data: str, expiry: datetime.datetime = ...) -> None: ...

class Cluster:
    """
    Represents a connection to the QuasarDB cluster.
    """

    def __enter__(self) -> Cluster: ...
    def __exit__(
        self, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any
    ) -> None: ...
    def __init__(
        self,
        uri: str,
        user_name: str = "",
        user_private_key: str = "",
        cluster_public_key: str = "",
        *,
        user_security_file: str = "",
        cluster_public_key_file: str = "",
        timeout: datetime.timedelta = ...,
        do_version_check: bool = False,
        enable_encryption: bool = False,
        compression_mode: Options.Compression = ...,
        client_max_parallelism: int = 0,
    ) -> None: ...
    def blob(self, arg0: str) -> ...: ...
    def close(self) -> None: ...
    def compact_abort(self) -> None: ...
    def compact_full(self) -> None: ...
    def compact_progress(self) -> int: ...
    def double(self, arg0: str) -> ...: ...
    def endpoints(self) -> list[str]: ...
    def find(self, arg0: str) -> ...: ...
    def get_memory_info(self) -> str: ...
    def inserter(self, arg0: list[...]) -> ...: ...
    def integer(self, arg0: str) -> ...: ...
    def is_open(self) -> bool: ...
    def node(self, arg0: str) -> ...: ...
    def node_config(self, arg0: str) -> typing.Any: ...
    def node_status(self, arg0: str) -> typing.Any: ...
    def node_topology(self, arg0: str) -> typing.Any: ...
    def options(self) -> Options: ...
    def perf(self) -> ...: ...
    def pinned_writer(self) -> ...: ...
    def prefix_count(self, arg0: str) -> int: ...
    def prefix_get(self, arg0: str, arg1: int) -> list[str]: ...
    def properties(self) -> ...: ...
    def purge_all(self, arg0: datetime.timedelta) -> None: ...
    def purge_cache(self, arg0: datetime.timedelta) -> None: ...
    def query(self, query: str, blobs: typing.Any = False) -> typing.Any: ...
    def query_continuous_full(
        self, query: str, pace: datetime.timedelta, blobs: typing.Any = False
    ) -> ...: ...
    def query_continuous_new_values(
        self, query: str, pace: datetime.timedelta, blobs: typing.Any = False
    ) -> ...: ...
    def query_numpy(self, query: str) -> typing.Any: ...
    def reader(
        self,
        table_names: list[str],
        *,
        column_names: list[str] = [],
        batch_size: int = 0,
        ranges: list[tuple] = [],
    ) -> ...: ...
    def string(self, arg0: str) -> ...: ...
    def suffix_count(self, arg0: str) -> int: ...
    def suffix_get(self, arg0: str, arg1: int) -> list[str]: ...
    def table(self, arg0: str) -> ...: ...
    def tag(self, arg0: str) -> ...: ...
    def tidy_memory(self) -> None: ...
    def timestamp(self, arg0: str) -> ...: ...
    def trim_all(self, arg0: datetime.timedelta, arg1: datetime.timedelta) -> None: ...
    def ts(self, arg0: str) -> ...: ...
    def ts_batch(self, arg0: list[...]) -> ...: ...
    def uri(self) -> str: ...
    def wait_for_compaction(self) -> None: ...
    def writer(self) -> ...: ...

class ColumnInfo:
    name: str
    symtable: str
    type: ColumnType
    @typing.overload
    def __init__(self, arg0: ColumnType, arg1: str) -> None: ...
    @typing.overload
    def __init__(self, arg0: ColumnType, arg1: str, arg2: str) -> None: ...
    def __repr__(self) -> str: ...

class ColumnType:
    """
    Column type

    Members:

      Uninitialized

      Double

      Blob

      String

      Symbol

      Int64

      Timestamp
    """

    Blob: typing.ClassVar[ColumnType]  # value = <ColumnType.Blob: 1>
    Double: typing.ClassVar[ColumnType]  # value = <ColumnType.Double: 0>
    Int64: typing.ClassVar[ColumnType]  # value = <ColumnType.Int64: 2>
    String: typing.ClassVar[ColumnType]  # value = <ColumnType.String: 4>
    Symbol: typing.ClassVar[ColumnType]  # value = <ColumnType.Symbol: 5>
    Timestamp: typing.ClassVar[ColumnType]  # value = <ColumnType.Timestamp: 3>
    Uninitialized: typing.ClassVar[ColumnType]  # value = <ColumnType.Uninitialized: -1>
    __members__: typing.ClassVar[
        dict[str, ColumnType]
    ]  # value = {'Uninitialized': <ColumnType.Uninitialized: -1>, 'Double': <ColumnType.Double: 0>, 'Blob': <ColumnType.Blob: 1>, 'String': <ColumnType.String: 4>, 'Symbol': <ColumnType.Symbol: 5>, 'Int64': <ColumnType.Int64: 2>, 'Timestamp': <ColumnType.Timestamp: 3>}
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DirectBlob:
    def __init__(self, arg0: ..., arg1: ..., arg2: str) -> None: ...
    def get(self) -> bytes: ...
    def put(self, data: str) -> None: ...
    def remove(self) -> None: ...
    def update(self, data: str) -> None: ...

class DirectInteger:
    def __init__(self, arg0: ..., arg1: ..., arg2: str) -> None: ...
    def get(self) -> int: ...
    def put(self, integer: int) -> None: ...
    def remove(self) -> None: ...
    def update(self, integer: int) -> None: ...

class Double(ExpirableEntry):
    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def add(self, addend: float) -> float: ...
    def get(self) -> float: ...
    def put(self, double: float) -> None: ...
    def update(self, double: float) -> None: ...

class Entry:
    class Metadata:
        expiry_time: qdb_timespec_t
        modification_time: qdb_timespec_t
        size: int
        type: Entry.Type
        def __init__(self) -> None: ...

    class Type:
        """
        Entry type

        Members:

          Uninitialized

          Integer

          HashSet

          Tag

          Deque

          Stream

          Timeseries
        """

        Deque: typing.ClassVar[Entry.Type]  # value = <Type.Deque: 4>
        HashSet: typing.ClassVar[Entry.Type]  # value = <Type.HashSet: 2>
        Integer: typing.ClassVar[Entry.Type]  # value = <Type.Integer: 1>
        Stream: typing.ClassVar[Entry.Type]  # value = <Type.Stream: 5>
        Tag: typing.ClassVar[Entry.Type]  # value = <Type.Tag: 3>
        Timeseries: typing.ClassVar[Entry.Type]  # value = <Type.Timeseries: 6>
        Uninitialized: typing.ClassVar[Entry.Type]  # value = <Type.Uninitialized: -1>
        __members__: typing.ClassVar[
            dict[str, Entry.Type]
        ]  # value = {'Uninitialized': <Type.Uninitialized: -1>, 'Integer': <Type.Integer: 1>, 'HashSet': <Type.HashSet: 2>, 'Tag': <Type.Tag: 3>, 'Deque': <Type.Deque: 4>, 'Stream': <Type.Stream: 5>, 'Timeseries': <Type.Timeseries: 6>}
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: typing.Any) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: typing.Any) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __repr__(self) -> str: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def attach_tag(self, arg0: str) -> bool: ...
    def attach_tags(self, arg0: list[str]) -> None: ...
    def detach_tag(self, arg0: str) -> bool: ...
    def detach_tags(self, arg0: list[str]) -> None: ...
    def exists(self) -> bool:
        """
        Returns true if the entry exists
        """

    def get_entry_type(self) -> Entry.Type: ...
    def get_location(self) -> tuple[str, int]: ...
    def get_metadata(self) -> ...: ...
    def get_name(self) -> str: ...
    def get_tags(self) -> list[str]: ...
    def has_tag(self, arg0: str) -> bool: ...
    def remove(self) -> None: ...

class Error(RuntimeError):
    pass

class ExpirableEntry(Entry):
    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def expires_at(self, arg0: ...) -> None: ...
    def expires_from_now(self, arg0: datetime.timedelta) -> None: ...
    def get_expiry_time(self) -> ...: ...

class FindQuery:
    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def run(self) -> list[str]: ...

class IncompatibleTypeError(Error):
    pass

class IndexedColumnInfo:
    @typing.overload
    def __init__(self, arg0: ColumnType, arg1: int) -> None: ...
    @typing.overload
    def __init__(self, arg0: ColumnType, arg1: int, arg2: str) -> None: ...
    @property
    def index(self) -> int: ...
    @property
    def symtable(self) -> str: ...
    @property
    def type(self) -> ColumnType: ...

class InputBufferTooSmallError(Error):
    pass

class Integer(ExpirableEntry):
    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def add(self, addend: int) -> int: ...
    def get(self) -> int: ...
    def put(self, integer: int) -> None: ...
    def update(self, integer: int) -> None: ...

class InternalLocalError(Error):
    pass

class InvalidArgumentError(Error):
    pass

class InvalidDatetimeError(Error):
    pass

class InvalidHandleError(Error):
    pass

class InvalidQueryError(Error):
    pass

class MaskedArray:
    pass

class Node:
    def __init__(
        self,
        uri: str,
        user_name: str = "",
        user_private_key: str = "",
        cluster_public_key: str = "",
        *,
        user_security_file: str = "",
        cluster_public_key_file: str = "",
        enable_encryption: bool = False,
    ) -> None: ...
    def blob(self, arg0: str) -> ...: ...
    def integer(self, arg0: str) -> ...: ...
    def prefix_get(self, arg0: str, arg1: int) -> list[str]: ...

class NotImplementedError(Error):
    pass

class Options:
    class Compression:
        """
        Compression mode

        Members:

          Disabled

          Best

          Balanced
        """

        Balanced: typing.ClassVar[
            Options.Compression
        ]  # value = <Compression.Balanced: 3>
        Best: typing.ClassVar[Options.Compression]  # value = <Compression.Best: 2>
        Disabled: typing.ClassVar[
            Options.Compression
        ]  # value = <Compression.Disabled: 0>
        __members__: typing.ClassVar[
            dict[str, Options.Compression]
        ]  # value = {'Disabled': <Compression.Disabled: 0>, 'Best': <Compression.Best: 2>, 'Balanced': <Compression.Balanced: 3>}
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: typing.Any) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: typing.Any) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __repr__(self) -> str: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Encryption:
        """
        Encryption type

        Members:

          Disabled

          AES256GCM
        """

        AES256GCM: typing.ClassVar[
            Options.Encryption
        ]  # value = <Encryption.AES256GCM: 1>
        Disabled: typing.ClassVar[
            Options.Encryption
        ]  # value = <Encryption.Disabled: 0>
        __members__: typing.ClassVar[
            dict[str, Options.Encryption]
        ]  # value = {'Disabled': <Encryption.Disabled: 0>, 'AES256GCM': <Encryption.AES256GCM: 1>}
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: typing.Any) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: typing.Any) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __repr__(self) -> str: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    def __init__(self, arg0: ...) -> None: ...
    def disable_user_properties(self) -> None: ...
    def enable_user_properties(self) -> None: ...
    def get_client_max_batch_load(self) -> int:
        """
        Get the number of shards per thread used for the batch writer.
        """

    def get_client_max_in_buf_size(self) -> int: ...
    def get_client_max_parallelism(self) -> int: ...
    def get_cluster_max_in_buf_size(self) -> int: ...
    def get_connection_per_address_soft_limit(self) -> int:
        """
        Get the maximum number of connections per qdbd node
        """

    def get_query_max_length(self) -> int: ...
    def get_stabilization_max_wait(self) -> datetime.timedelta: ...
    def get_timeout(self) -> datetime.timedelta: ...
    def get_timezone(self) -> str: ...
    def set_client_max_batch_load(self, arg0: int) -> None:
        """
        Adjust the number of shards per thread used for the batch writer.
        """

    def set_client_max_in_buf_size(self, arg0: int) -> None: ...
    def set_client_soft_memory_limit(self, limit: int) -> None: ...
    def set_cluster_public_key(self, arg0: str) -> None: ...
    def set_connection_per_address_soft_limit(self, arg0: int) -> None:
        """
        Adjust the maximum number of connections per qdbd node
        """

    def set_encryption(self, arg0: Options.Encryption) -> None: ...
    def set_max_cardinality(self, arg0: int) -> None: ...
    def set_query_max_length(self, query_max_length: int) -> None: ...
    def set_stabilization_max_wait(self, arg0: datetime.timedelta) -> None: ...
    def set_timeout(self, arg0: datetime.timedelta) -> None: ...
    def set_timezone(self, arg0: str) -> None: ...
    def set_user_credentials(self, arg0: str, arg1: str) -> None: ...

class OutOfBoundsError(Error):
    pass

class Perf:
    def __init__(self, arg0: ...) -> None: ...
    def clear(self) -> None: ...
    def disable(self) -> None: ...
    def enable(self) -> None: ...
    def get(self, flame: bool = False, outfile: str = "") -> typing.Any: ...

class Properties:
    def __init__(self, arg0: ...) -> None: ...
    def clear(self) -> None: ...
    def get(self, arg0: str) -> str | None: ...
    def put(self, arg0: str, arg1: str) -> None: ...
    def remove(self, arg0: str) -> None: ...

class QueryContinuous:
    def __init__(self, arg0: ..., arg1: typing.Any) -> None: ...
    def __iter__(self) -> QueryContinuous: ...
    def __next__(self) -> list[dict[str, typing.Any]]: ...
    def probe_results(self) -> list[dict[str, typing.Any]]: ...
    def results(self) -> list[dict[str, typing.Any]]: ...
    def run(
        self,
        arg0: qdb_query_continuous_mode_type_t,
        arg1: datetime.timedelta,
        arg2: str,
    ) -> None: ...
    def stop(self) -> None: ...

class Reader:
    def __enter__(self) -> Reader: ...
    def __exit__(
        self, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any
    ) -> None: ...
    def __init__(
        self,
        conn: ...,
        table_names: list[str],
        *,
        column_names: list[str] = [],
        batch_size: int = 65536,
        ranges: list[tuple] = [],
    ) -> None: ...
    def __iter__(self) -> typing.Iterator[dict]: ...
    def get_batch_size(self) -> int: ...

class RetryOptions:
    delay: datetime.timedelta
    exponent: int
    jitter: float
    retries_left: int
    def __init__(
        self,
        retries: int = 3,
        *,
        delay: datetime.timedelta = ...,
        exponent: int = 2,
        jitter: float = 0.1,
    ) -> None: ...
    def has_next(self) -> bool: ...
    def next(self) -> RetryOptions: ...

class String(ExpirableEntry):
    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def compare_and_swap(self, new_content: str, comparand: str) -> str: ...
    def get(self) -> str: ...
    def get_and_remove(self) -> str: ...
    def get_and_update(self, data: str) -> str: ...
    def put(self, data: str) -> None: ...
    def remove_if(self, comparand: str) -> None: ...
    def update(self, data: str, expiry: datetime.datetime = ...) -> None: ...

class Table(Entry):
    """
    Table representation
    """

    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def __repr__(self) -> str: ...
    def blob_get_ranges(
        self, column: str, ranges: typing.Any = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def blob_insert(
        self, arg0: str, arg1: numpy.ndarray, arg2: numpy.ma.MaskedArray
    ) -> None: ...
    def column_id_by_index(self, arg0: int) -> str: ...
    def column_index_by_id(self, arg0: str) -> int: ...
    def column_info_by_index(self, arg0: int) -> ...: ...
    def column_type_by_id(self, arg0: str) -> ColumnType: ...
    def column_type_by_index(self, arg0: int) -> ColumnType: ...
    def create(
        self,
        columns: list[...],
        shard_size: datetime.timedelta = ...,
        ttl: datetime.timedelta = ...,
    ) -> None: ...
    def double_get_ranges(
        self, column: str, ranges: typing.Any = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def double_insert(
        self, arg0: str, arg1: numpy.ndarray, arg2: numpy.ma.MaskedArray
    ) -> None: ...
    def erase_ranges(self, arg0: str, arg1: typing.Any) -> int: ...
    def get_name(self: Entry) -> str: ...
    def get_shard_size(self) -> datetime.timedelta: ...
    def get_ttl(self) -> datetime.timedelta: ...
    def has_ttl(self) -> bool: ...
    def insert_columns(self, arg0: list[...]) -> None: ...
    def int64_get_ranges(
        self, column: str, ranges: typing.Any = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def int64_insert(
        self, arg0: str, arg1: numpy.ndarray, arg2: numpy.ma.MaskedArray
    ) -> None: ...
    def list_columns(self) -> list[...]: ...
    def reader(
        self,
        *,
        column_names: list[str] = [],
        batch_size: int = 0,
        ranges: list[tuple] = [],
    ) -> ...: ...
    def retrieve_metadata(self) -> None: ...
    def string_get_ranges(
        self, column: str, ranges: typing.Any = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def string_insert(
        self, arg0: str, arg1: numpy.ndarray, arg2: numpy.ma.MaskedArray
    ) -> None: ...
    def subscribe(self, arg0: typing.Any) -> typing.Any: ...
    def timestamp_get_ranges(
        self, column: str, ranges: typing.Any = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def timestamp_insert(
        self, arg0: str, arg1: numpy.ndarray, arg2: numpy.ma.MaskedArray
    ) -> None: ...

class Tag(Entry):
    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def count(self) -> int: ...
    def get_entries(self) -> list[str]: ...

class Timestamp(ExpirableEntry):
    def __init__(self, arg0: ..., arg1: str) -> None: ...
    def add(self, addend: ...) -> ...: ...
    def get(self) -> ...: ...
    def put(self, timestamp: ...) -> None: ...
    def update(self, timestamp: ...) -> None: ...

class TryAgainError(Error):
    pass

class UninitializedError(Error):
    pass

class WriterData:
    def __init__(self) -> None: ...
    def append(self, table: Table, index: typing.Any, column_data: list) -> None:
        """
        Append new data
        """

    def empty(self) -> bool:
        """
        Returns true if underlying data is empty
        """

class WriterPushMode:
    """
    Push Mode

    Members:

      Transactional

      Fast

      Truncate

      Async
    """

    Async: typing.ClassVar[WriterPushMode]  # value = <WriterPushMode.Async: 3>
    Fast: typing.ClassVar[WriterPushMode]  # value = <WriterPushMode.Fast: 2>
    Transactional: typing.ClassVar[
        WriterPushMode
    ]  # value = <WriterPushMode.Transactional: 0>
    Truncate: typing.ClassVar[WriterPushMode]  # value = <WriterPushMode.Truncate: 1>
    __members__: typing.ClassVar[
        dict[str, WriterPushMode]
    ]  # value = {'Transactional': <WriterPushMode.Transactional: 0>, 'Fast': <WriterPushMode.Fast: 2>, 'Truncate': <WriterPushMode.Truncate: 1>, 'Async': <WriterPushMode.Async: 3>}
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def build() -> str:
    """
    Return build number
    """

def dict_query(
    arg0: ..., arg1: str, arg2: typing.Any
) -> list[dict[str, typing.Any]]: ...
def version() -> str:
    """
    Return version number
    """

Writer = None
never_expires: datetime.datetime  # value = datetime.datetime(1969, 12, 31, 19, 0)
