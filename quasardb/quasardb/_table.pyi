from __future__ import annotations

import datetime
import typing

import numpy

from quasardb.quasardb._reader import Reader

from ._entry import Entry

class ColumnType:
    Uninitialized: ColumnType  # value = <ColumnType.Uninitialized: -1>
    Double: ColumnType  # value = <ColumnType.Double: 0>
    Blob: ColumnType  # value = <ColumnType.Blob: 1>
    Int64: ColumnType  # value = <ColumnType.Int64: 2>
    Timestamp: ColumnType  # value = <ColumnType.Timestamp: 3>
    String: ColumnType  # value = <ColumnType.String: 4>
    Symbol: ColumnType  # value = <ColumnType.Symbol: 5>
    __members__: dict[str, ColumnType]
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ColumnInfo:
    name: str
    symtable: str
    type: ColumnType
    @typing.overload
    def __init__(self, type: ColumnType, name: str) -> None: ...
    @typing.overload
    def __init__(self, type: ColumnType, name: str, symtable: str) -> None: ...
    def __repr__(self) -> str: ...

class IndexedColumnInfo:
    @typing.overload
    def __init__(self, type: ColumnType, index: int) -> None: ...
    @typing.overload
    def __init__(self, type: ColumnType, index: int, symtable: str) -> None: ...
    @property
    def index(self) -> int: ...
    @property
    def symtable(self) -> str: ...
    @property
    def type(self) -> ColumnType: ...

class Table(Entry):
    def __repr__(self) -> str: ...
    def blob_get_ranges(
        self, column: str, ranges: object = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def blob_insert(
        self, column: str, timestamps: numpy.ndarray, values: numpy.ma.MaskedArray
    ) -> None: ...
    def column_id_by_index(self, index: int) -> str: ...
    def column_index_by_id(self, alias: str) -> int: ...
    def column_info_by_index(self, index: int) -> ColumnInfo: ...
    def column_type_by_id(self, alias: str) -> ColumnType: ...
    def column_type_by_index(self, index: int) -> ColumnType: ...
    def create(
        self,
        columns: list[ColumnInfo],
        shard_size: datetime.timedelta = ...,
        ttl: datetime.timedelta = ...,
    ) -> None: ...
    def double_get_ranges(
        self, column: str, ranges: object = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def double_insert(
        self, column: str, timestamps: numpy.ndarray, values: numpy.ma.MaskedArray
    ) -> None: ...
    def erase_ranges(self, column: str, ranges: object) -> int: ...
    def get_shard_size(self) -> datetime.timedelta: ...
    def get_ttl(self) -> datetime.timedelta: ...
    def has_ttl(self) -> bool: ...
    def insert_columns(self, columns: list[ColumnInfo]) -> None: ...
    def int64_get_ranges(
        self, column: str, ranges: object = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def int64_insert(
        self, column: str, timestamps: numpy.ndarray, values: numpy.ma.MaskedArray
    ) -> None: ...
    def list_columns(self) -> list[ColumnInfo]: ...
    def reader(
        self,
        column_names: list[str] = [],
        batch_size: int = 0,
        ranges: list[tuple] = [],
    ) -> Reader: ...
    def retrieve_metadata(self) -> None: ...
    def string_get_ranges(
        self, column: str, ranges: object = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def string_insert(
        self, column: str, timestamps: numpy.ndarray, values: numpy.ma.MaskedArray
    ) -> None: ...
    def subscribe(self, conn: object) -> object: ...
    def timestamp_get_ranges(
        self, column: str, ranges: object = None
    ) -> tuple[numpy.ndarray, numpy.ma.MaskedArray]: ...
    def timestamp_insert(
        self, column: str, timestamps: numpy.ndarray, values: numpy.ma.MaskedArray
    ) -> None: ...
