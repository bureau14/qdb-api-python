from __future__ import annotations

import datetime

class Options:
    class Compression:
        Disabled: Options.Compression  # value = <Compression.Disabled: 0>
        Best: Options.Compression  # value = <Compression.Best: 2>
        Balanced: Options.Compression  # value = <Compression.Balanced: 3>
        __members__: dict[str, Options.Compression]
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __repr__(self) -> str: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Encryption:
        Disabled: Options.Encryption  # value = <Encryption.Disabled: 0>
        AES256GCM: Options.Encryption  # value = <Encryption.AES256GCM: 1>
        __members__: dict[str, Options.Encryption]
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __repr__(self) -> str: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    def disable_user_properties(self) -> None: ...
    def enable_user_properties(self) -> None: ...
    def get_client_max_batch_load(self) -> int:
        """
        Get the number of shards per thread used for the batch writer.
        """

    def get_client_max_in_buf_size(self) -> int: ...
    def get_client_max_parallelism(self) -> int: ...
    def get_cluster_max_in_buf_size(self) -> int: ...
    def get_connection_per_address_soft_limit(self) -> int:
        """
        Get the maximum number of connections per qdbd node
        """

    def get_query_max_length(self) -> int: ...
    def get_stabilization_max_wait(self) -> datetime.timedelta: ...
    def get_timeout(self) -> datetime.timedelta: ...
    def get_timezone(self) -> str: ...
    def set_client_max_batch_load(self, shard_count: int) -> None:
        """
        Adjust the number of shards per thread used for the batch writer.
        """

    def set_client_max_in_buf_size(self, max_size: int) -> None: ...
    def set_client_soft_memory_limit(self, limit: int) -> None: ...
    def set_cluster_public_key(self, key: str) -> None: ...
    def set_connection_per_address_soft_limit(self, max_count: int) -> None:
        """
        Adjust the maximum number of connections per qdbd node
        """

    def set_encryption(self, algorithm: Options.Encryption) -> None: ...
    def set_max_cardinality(self, cardinality: int) -> None: ...
    def set_query_max_length(self, query_max_length: int) -> None: ...
    def set_stabilization_max_wait(self, max_wait: datetime.timedelta) -> None: ...
    def set_timeout(self, timeout: datetime.timedelta) -> None: ...
    def set_timezone(self, tz: str) -> None: ...
    def set_user_credentials(self, user: str, private_key: str) -> None: ...
