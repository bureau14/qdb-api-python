From f3b0bdc5315277aeea130a3980aa361a598e3bc0 Mon Sep 17 00:00:00 2001
From: vikonix <valeriy.kovalev.software@gmail.com>
Date: Wed, 13 Jul 2022 23:24:06 +0200
Subject: [PATCH] qdb patch fix arm linker

---
 cmake_modules/linker_flags.cmake              |   6 +
 thirdparty/arrow/CMakeLists.txt               | 103 ++++++++++--------
 .../arrow/cmake_modules/SetupCxxFlags.cmake   |  13 ++-
 thirdparty/arrow/src/arrow/CMakeLists.txt     |  67 ++++++++++--
 .../arrow/src/arrow/array/builder_base.h      |   4 +-
 .../arrow/src/arrow/array/builder_primitive.h |   2 +-
 thirdparty/arrow/src/arrow/buffer_builder.h   |   2 +-
 thirdparty/arrow/src/arrow/c/abi.h            |   5 +-
 thirdparty/arrow/src/arrow/config.h           |   2 +-
 thirdparty/arrow/src/arrow/io/CMakeLists.txt  |   2 +
 thirdparty/arrow/src/arrow/sparse_tensor.cc   |   1 +
 thirdparty/arrow/src/arrow/type.cc            |   2 +-
 thirdparty/arrow/src/arrow/type.h             |   4 +-
 thirdparty/arrow/src/arrow/util/bit_util.h    |  31 ++++++
 .../arrow/src/arrow/util/bitmap_generate.h    |   3 +-
 thirdparty/arrow/src/arrow/util/utf8.h        |   6 +-
 thirdparty/arrow/src/arrow/util/variant.h     |   6 +-
 17 files changed, 181 insertions(+), 78 deletions(-)

diff --git a/cmake_modules/linker_flags.cmake b/cmake_modules/linker_flags.cmake
index 9167977ac3..56e77c8c22 100644
--- a/cmake_modules/linker_flags.cmake
+++ b/cmake_modules/linker_flags.cmake
@@ -154,6 +154,12 @@ if(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
             --coverage
         )
     endif()
+    if(QDB_CPU_IS_ARM)
+        add_link_options(
+            -pthread
+        )
+    endif()
+
 endif()
 
 # TODO(Marek): Group all *San build types into a single Sanitize and add QDB_SANITIZERS options taking a list.
diff --git a/thirdparty/arrow/CMakeLists.txt b/thirdparty/arrow/CMakeLists.txt
index aba18c8d24..bd47b8832b 100644
--- a/thirdparty/arrow/CMakeLists.txt
+++ b/thirdparty/arrow/CMakeLists.txt
@@ -15,6 +15,7 @@
 # specific language governing permissions and limitations
 # under the License.
 
+set(CMAKE_CXX_STANDARD 17)
 cmake_minimum_required(VERSION 3.5)
 message(STATUS "Building using CMake version: ${CMAKE_VERSION}")
 
@@ -124,7 +125,7 @@ list(GET ARROW_LLVM_VERSIONS 0 ARROW_LLVM_VERSION_PRIMARY)
 string(REGEX REPLACE "^([0-9]+)(\\..+)?" "\\1" ARROW_LLVM_VERSION_PRIMARY_MAJOR
                      "${ARROW_LLVM_VERSION_PRIMARY}")
 
-file(READ ${CMAKE_CURRENT_SOURCE_DIR}/../.env ARROW_ENV)
+#file(READ ${CMAKE_CURRENT_SOURCE_DIR}/../.env ARROW_ENV)
 string(REGEX MATCH "CLANG_TOOLS=[^\n]+" ARROW_ENV_CLANG_TOOLS_VERSION "${ARROW_ENV}")
 string(REGEX REPLACE "^CLANG_TOOLS=" "" ARROW_CLANG_TOOLS_VERSION
                      "${ARROW_ENV_CLANG_TOOLS_VERSION}")
@@ -175,7 +176,7 @@ endif()
 
 # ----------------------------------------------------------------------
 # cmake options
-include(DefineOptions)
+#include(DefineOptions)
 
 # Needed for linting targets, etc.
 if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
@@ -515,27 +516,27 @@ else()
   set(BUILD_OUTPUT_ROOT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/${BUILD_SUBDIR_NAME}/")
 endif()
 
-# where to put generated archives (.a files)
-set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${BUILD_OUTPUT_ROOT_DIRECTORY}")
-set(ARCHIVE_OUTPUT_DIRECTORY "${BUILD_OUTPUT_ROOT_DIRECTORY}")
-
-# where to put generated libraries (.so files)
-set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${BUILD_OUTPUT_ROOT_DIRECTORY}")
-set(LIBRARY_OUTPUT_DIRECTORY "${BUILD_OUTPUT_ROOT_DIRECTORY}")
-
-# where to put generated binaries
-set(EXECUTABLE_OUTPUT_PATH "${BUILD_OUTPUT_ROOT_DIRECTORY}")
-
-if(CMAKE_GENERATOR STREQUAL Xcode)
-  # Xcode projects support multi-configuration builds.  This forces a single output directory
-  # when building with Xcode that is consistent with single-configuration Makefile driven build.
-  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${UPPERCASE_BUILD_TYPE}
-      "${BUILD_OUTPUT_ROOT_DIRECTORY}")
-  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${UPPERCASE_BUILD_TYPE}
-      "${BUILD_OUTPUT_ROOT_DIRECTORY}")
-  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${UPPERCASE_BUILD_TYPE}
-      "${BUILD_OUTPUT_ROOT_DIRECTORY}")
-endif()
+## where to put generated archives (.a files)
+#set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${BUILD_OUTPUT_ROOT_DIRECTORY}")
+#set(ARCHIVE_OUTPUT_DIRECTORY "${BUILD_OUTPUT_ROOT_DIRECTORY}")
+#
+## where to put generated libraries (.so files)
+#set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${BUILD_OUTPUT_ROOT_DIRECTORY}")
+#set(LIBRARY_OUTPUT_DIRECTORY "${BUILD_OUTPUT_ROOT_DIRECTORY}")
+#
+## where to put generated binaries
+#set(EXECUTABLE_OUTPUT_PATH "${BUILD_OUTPUT_ROOT_DIRECTORY}")
+#
+#if(CMAKE_GENERATOR STREQUAL Xcode)
+#  # Xcode projects support multi-configuration builds.  This forces a single output directory
+#  # when building with Xcode that is consistent with single-configuration Makefile driven build.
+#  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${UPPERCASE_BUILD_TYPE}
+#      "${BUILD_OUTPUT_ROOT_DIRECTORY}")
+#  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${UPPERCASE_BUILD_TYPE}
+#      "${BUILD_OUTPUT_ROOT_DIRECTORY}")
+#  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${UPPERCASE_BUILD_TYPE}
+#      "${BUILD_OUTPUT_ROOT_DIRECTORY}")
+#endif()
 
 #
 # Dependencies
@@ -549,7 +550,10 @@ enable_testing()
 set(ARROW_PC_REQUIRES_PRIVATE)
 set(ARROW_PC_LIBS_PRIVATE)
 
-include(ThirdpartyToolchain)
+#include(ThirdpartyToolchain)
+configure_file("src/arrow/util/config.h.cmake" "src/arrow/util/config.h" ESCAPE_QUOTES)
+install(FILES "${ARROW_BINARY_DIR}/src/arrow/util/config.h"
+        DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/arrow/util")
 
 # Add common flags
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXX_COMMON_FLAGS}")
@@ -581,11 +585,13 @@ endif()
 message(STATUS "CMAKE_C_FLAGS: ${CMAKE_C_FLAGS}")
 message(STATUS "CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}")
 
-include_directories(${CMAKE_CURRENT_BINARY_DIR}/src)
-include_directories(src)
+include_directories(SYSTEM ${CMAKE_CURRENT_BINARY_DIR}/src)
+include_directories(SYSTEM src)
+include_directories(SYSTEM thirdparty/hadoop/include)
+include_directories(SYSTEM thirdparty/xsimd/include)
 
 # Compiled flatbuffers files
-include_directories(src/generated)
+include_directories(SYSTEM src/generated)
 
 #
 # Visibility
@@ -808,15 +814,15 @@ if(ARROW_WITH_RE2)
   endif()
 endif()
 
-add_custom_target(arrow_dependencies)
-add_custom_target(arrow_benchmark_dependencies)
-add_custom_target(arrow_test_dependencies)
+#add_custom_target(arrow_dependencies)
+#add_custom_target(arrow_benchmark_dependencies)
+#add_custom_target(arrow_test_dependencies)
 
-# ARROW-4581: CMake can be finicky about invoking the ExternalProject builds
-# for some of the library dependencies, so we "nuke it from orbit" by making
-# the toolchain dependency explicit using these "dependencies" targets
-add_dependencies(arrow_dependencies toolchain)
-add_dependencies(arrow_test_dependencies toolchain-tests)
+## ARROW-4581: CMake can be finicky about invoking the ExternalProject builds
+## for some of the library dependencies, so we "nuke it from orbit" by making
+## the toolchain dependency explicit using these "dependencies" targets
+#add_dependencies(arrow_dependencies toolchain)
+#add_dependencies(arrow_test_dependencies toolchain-tests)
 
 if(ARROW_STATIC_LINK_LIBS)
   add_dependencies(arrow_dependencies ${ARROW_STATIC_LINK_LIBS})
@@ -945,20 +951,21 @@ list(APPEND ARROW_STATIC_INSTALL_INTERFACE_LIBS ${ARROW_SYSTEM_LINK_LIBS})
 # Subdirectories
 #
 
-if(NOT WIN32 AND ARROW_PLASMA)
-  add_subdirectory(src/plasma)
-endif()
+#if(NOT WIN32 AND ARROW_PLASMA)
+#  add_subdirectory(src/plasma)
+#endif()
 
 add_subdirectory(src/arrow)
 
 if(ARROW_PARQUET)
   add_subdirectory(src/parquet)
-  add_subdirectory(tools/parquet)
-  if(PARQUET_BUILD_EXAMPLES)
-    add_subdirectory(examples/parquet)
-  endif()
+#  add_subdirectory(tools/parquet)
+#  if(PARQUET_BUILD_EXAMPLES)
+#    add_subdirectory(examples/parquet)
+#  endif()
 endif()
 
+#[[
 if(ARROW_JNI)
   add_subdirectory(src/jni)
 endif()
@@ -979,13 +986,13 @@ endif()
 install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/../LICENSE.txt
               ${CMAKE_CURRENT_SOURCE_DIR}/../NOTICE.txt
               ${CMAKE_CURRENT_SOURCE_DIR}/README.md DESTINATION "${ARROW_DOC_DIR}")
-
+]]
 #
 # Validate and print out Arrow configuration options
 #
 
-validate_config()
-config_summary_message()
-if(${ARROW_BUILD_CONFIG_SUMMARY_JSON})
-  config_summary_json()
-endif()
+#validate_config()
+#config_summary_message()
+#if(${ARROW_BUILD_CONFIG_SUMMARY_JSON})
+#  config_summary_json()
+#endif()
diff --git a/thirdparty/arrow/cmake_modules/SetupCxxFlags.cmake b/thirdparty/arrow/cmake_modules/SetupCxxFlags.cmake
index a11f37dd4d..e0881f5a89 100644
--- a/thirdparty/arrow/cmake_modules/SetupCxxFlags.cmake
+++ b/thirdparty/arrow/cmake_modules/SetupCxxFlags.cmake
@@ -26,7 +26,7 @@ message(STATUS "System processor: ${CMAKE_SYSTEM_PROCESSOR}")
 if(NOT DEFINED ARROW_CPU_FLAG)
   if(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64|ARM64|arm64")
     set(ARROW_CPU_FLAG "armv8")
-  elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "armv7")
+  elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "armv7|arm|armhf")
     set(ARROW_CPU_FLAG "armv7")
   elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "powerpc|ppc")
     set(ARROW_CPU_FLAG "ppc")
@@ -106,6 +106,7 @@ elseif(ARROW_CPU_FLAG STREQUAL "ppc")
   endif()
 elseif(ARROW_CPU_FLAG STREQUAL "armv8")
   # Arm64 compiler flags, gcc/clang only
+  set(ARROW_ARMV8_ARCH "armv8-a")
   set(ARROW_ARMV8_ARCH_FLAG "-march=${ARROW_ARMV8_ARCH}")
   check_cxx_compiler_flag(${ARROW_ARMV8_ARCH_FLAG} CXX_SUPPORTS_ARMV8_ARCH)
   if(ARROW_SIMD_LEVEL STREQUAL "DEFAULT")
@@ -286,19 +287,23 @@ if("${BUILD_WARNING_LEVEL}" STREQUAL "CHECKIN")
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-missing-braces")
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-unused-parameter")
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-constant-logical-operand")
+    set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-unknown-warning-option")
   elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wall")
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-conversion")
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-deprecated-declarations")
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-sign-conversion")
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wunused-result")
+    set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-unused-variable")
   elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
     if(WIN32)
       set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} /Wall")
       set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} /Wno-deprecated")
+      set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} /Wno-unused-variable")
     else()
       set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wall")
       set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-deprecated")
+      set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} -Wno-unused-variable")
     endif()
   else()
     message(FATAL_ERROR "${UNKNOWN_COMPILER_MESSAGE}")
@@ -471,7 +476,7 @@ endif()
 
 if(ARROW_CPU_FLAG STREQUAL "armv8")
   if(ARROW_SIMD_LEVEL STREQUAL "NEON")
-    set(ARROW_HAVE_NEON ON)
+#    set(ARROW_HAVE_NEON ON)
 
     if(NOT CXX_SUPPORTS_ARMV8_ARCH)
       message(FATAL_ERROR "Unsupported arch flag: ${ARROW_ARMV8_ARCH_FLAG}.")
@@ -481,7 +486,7 @@ if(ARROW_CPU_FLAG STREQUAL "armv8")
     endif()
     set(CXX_COMMON_FLAGS "${CXX_COMMON_FLAGS} ${ARROW_ARMV8_ARCH_FLAG}")
 
-    add_definitions(-DARROW_HAVE_NEON)
+#    add_definitions(-DARROW_HAVE_NEON)
 
     if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS
                                                 "5.4")
@@ -644,7 +649,7 @@ elseif("${CMAKE_BUILD_TYPE}" STREQUAL "PROFILE_BUILD")
   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${C_FLAGS_PROFILE_BUILD}")
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXX_FLAGS_PROFILE_BUILD}")
 else()
-  message(FATAL_ERROR "Unknown build type: ${CMAKE_BUILD_TYPE}")
+  #message(FATAL_ERROR "Unknown build type: ${CMAKE_BUILD_TYPE}")
 endif()
 
 message(STATUS "Build Type: ${CMAKE_BUILD_TYPE}")
diff --git a/thirdparty/arrow/src/arrow/CMakeLists.txt b/thirdparty/arrow/src/arrow/CMakeLists.txt
index 690c51a4a6..542e9d862b 100644
--- a/thirdparty/arrow/src/arrow/CMakeLists.txt
+++ b/thirdparty/arrow/src/arrow/CMakeLists.txt
@@ -15,6 +15,7 @@
 # specific language governing permissions and limitations
 # under the License.
 
+#[[
 add_custom_target(arrow-all)
 add_custom_target(arrow)
 add_custom_target(arrow-benchmarks)
@@ -25,6 +26,13 @@ add_dependencies(arrow-all
                  arrow-tests
                  arrow-benchmarks
                  arrow-integration)
+]]
+
+if(BUILD_SHARED_LIBS)
+  set(ARROW_BUILD_STATIC false)
+else()
+  set(ARROW_BUILD_STATIC true)
+endif()
 
 # Adding unit tests part of the "arrow" portion of the test suite
 function(ADD_ARROW_TEST REL_TEST_NAME)
@@ -549,6 +557,7 @@ if(${CMAKE_SYSTEM_NAME} STREQUAL "Linux" AND ${CMAKE_SYSTEM_PROCESSOR} MATCHES "
   string(APPEND ARROW_PC_LIBS_PRIVATE " -latomic")
 endif()
 
+#[[
 add_arrow_lib(arrow
               CMAKE_PACKAGE_NAME
               Arrow
@@ -583,6 +592,30 @@ endif()
 foreach(LIB_TARGET ${ARROW_LIBRARIES})
   target_compile_definitions(${LIB_TARGET} PRIVATE ARROW_EXPORTING)
 endforeach()
+]]
+
+set(ARROW_ALL_SRCS ${ARROW_SRCS} ${ARROW_C_SRCS})
+
+if(ARROW_BUILD_STATIC)
+  add_library(arrow STATIC ${ARROW_ALL_SRCS})
+  target_compile_definitions(arrow PUBLIC ARROW_STATIC)
+else()
+  add_library(arrow SHARED ${ARROW_ALL_SRCS})
+  target_compile_definitions(arrow PRIVATE ARROW_EXPORTING)
+  if(MSVC)
+    target_link_libraries(arrow PRIVATE psapi.lib)
+  endif()
+endif()
+target_include_directories(arrow SYSTEM PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/..")
+
+if(MSVC)
+  target_compile_options(arrow PRIVATE 
+    /wd4458 # declaration masking class member
+    /wd4100 # unreferenced parameter
+    /wd4201 # unnamed struct/union
+    /wd4702 # unreachable code
+  )
+endif()
 
 if(ARROW_WITH_BACKTRACE)
   find_package(Backtrace)
@@ -639,19 +672,20 @@ if(ARROW_TESTING)
   endforeach()
 endif()
 
-arrow_install_all_headers("arrow")
-
-config_summary_cmake_setters("${CMAKE_CURRENT_BINARY_DIR}/ArrowOptions.cmake")
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/ArrowOptions.cmake
-        DESTINATION "${ARROW_CMAKE_INSTALL_DIR}")
-
-# For backward compatibility for find_package(arrow)
-install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/arrow-config.cmake
-        DESTINATION "${ARROW_CMAKE_INSTALL_DIR}")
+#arrow_install_all_headers("arrow")
+#
+#config_summary_cmake_setters("${CMAKE_CURRENT_BINARY_DIR}/ArrowOptions.cmake")
+#install(FILES ${CMAKE_CURRENT_BINARY_DIR}/ArrowOptions.cmake
+#        DESTINATION "${ARROW_CMAKE_INSTALL_DIR}")
+#
+## For backward compatibility for find_package(arrow)
+#install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/arrow-config.cmake
+#        DESTINATION "${ARROW_CMAKE_INSTALL_DIR}")
 
 #
 # Unit tests
 #
+#[[
 add_arrow_test(array_test
                SOURCES
                array/array_test.cc
@@ -665,12 +699,21 @@ add_arrow_test(array_test
                "$<$<COMPILE_LANGUAGE:CXX>:arrow/testing/pch.h>")
 
 add_arrow_test(buffer_test)
+]]
 
 if(ARROW_IPC)
   # The extension type unit tests require IPC / Flatbuffers support
   add_arrow_test(extension_type_test)
 endif()
 
+set_source_files_properties(public_api_test.cc
+                            PROPERTIES
+                            SKIP_PRECOMPILE_HEADERS
+                            ON
+                            SKIP_UNITY_BUILD_INCLUSION
+                            ON)
+
+#[[
 add_arrow_test(misc_test
                SOURCES
                datum_test.cc
@@ -696,25 +739,29 @@ add_arrow_test(table_test
 
 add_arrow_test(tensor_test)
 add_arrow_test(sparse_tensor_test)
+]]
 
 set(STL_TEST_SRCS stl_iterator_test.cc)
 if(ARROW_COMPUTE)
   # This unit test uses compute code
   list(APPEND STL_TEST_SRCS stl_test.cc)
 endif()
+
+#[[
 add_arrow_test(stl_test SOURCES ${STL_TEST_SRCS})
 
 add_arrow_benchmark(builder_benchmark)
 add_arrow_benchmark(compare_benchmark)
 add_arrow_benchmark(memory_pool_benchmark)
 add_arrow_benchmark(type_benchmark)
+]]
 
 #
 # Recurse into sub-directories
 #
 
 # Unconditionally install testing headers that are also useful for Arrow consumers.
-add_subdirectory(testing)
+#add_subdirectory(testing)
 
 add_subdirectory(array)
 add_subdirectory(c)
diff --git a/thirdparty/arrow/src/arrow/array/builder_base.h b/thirdparty/arrow/src/arrow/array/builder_base.h
index 4d0b477dcb..85a6435923 100644
--- a/thirdparty/arrow/src/arrow/array/builder_base.h
+++ b/thirdparty/arrow/src/arrow/array/builder_base.h
@@ -147,8 +147,8 @@ class ARROW_EXPORT ArrayBuilder {
   /// \brief Append a range of values from an array.
   ///
   /// The given array must be the same type as the builder.
-  virtual Status AppendArraySlice(const ArrayData& array, int64_t offset,
-                                  int64_t length) {
+  virtual Status AppendArraySlice(const ArrayData& /*array*/, int64_t /*offset*/,
+                                  int64_t /*length*/) {
     return Status::NotImplemented("AppendArraySlice for builder for ", *type());
   }
 
diff --git a/thirdparty/arrow/src/arrow/array/builder_primitive.h b/thirdparty/arrow/src/arrow/array/builder_primitive.h
index c72b48f0b3..5e9de67415 100644
--- a/thirdparty/arrow/src/arrow/array/builder_primitive.h
+++ b/thirdparty/arrow/src/arrow/array/builder_primitive.h
@@ -32,7 +32,7 @@ namespace arrow {
 class ARROW_EXPORT NullBuilder : public ArrayBuilder {
  public:
   explicit NullBuilder(MemoryPool* pool = default_memory_pool()) : ArrayBuilder(pool) {}
-  explicit NullBuilder(const std::shared_ptr<DataType>& type,
+  explicit NullBuilder(const std::shared_ptr<DataType>& /*type*/,
                        MemoryPool* pool = default_memory_pool())
       : NullBuilder(pool) {}
 
diff --git a/thirdparty/arrow/src/arrow/buffer_builder.h b/thirdparty/arrow/src/arrow/buffer_builder.h
index d92a01a16e..aef3e584fe 100644
--- a/thirdparty/arrow/src/arrow/buffer_builder.h
+++ b/thirdparty/arrow/src/arrow/buffer_builder.h
@@ -345,7 +345,7 @@ class TypedBufferBuilder<bool> {
     if (num_elements == 0) return;
     int64_t i = 0;
     internal::GenerateBitsUnrolled(mutable_data(), bit_length_, num_elements, [&] {
-      bool value = bytes[i++];
+      bool value = (bool)bytes[i++];
       false_count_ += !value;
       return value;
     });
diff --git a/thirdparty/arrow/src/arrow/c/abi.h b/thirdparty/arrow/src/arrow/c/abi.h
index a78170dbdb..f8f4b69735 100644
--- a/thirdparty/arrow/src/arrow/c/abi.h
+++ b/thirdparty/arrow/src/arrow/c/abi.h
@@ -15,7 +15,8 @@
 // specific language governing permissions and limitations
 // under the License.
 
-#pragma once
+#ifndef QDB_API_ARROW_ABI_H
+#define QDB_API_ARROW_ABI_H
 
 #include <stdint.h>
 
@@ -101,3 +102,5 @@ struct ArrowArrayStream {
 #ifdef __cplusplus
 }
 #endif
+
+#endif /* QDB_API_ARROW_ABI_H */
\ No newline at end of file
diff --git a/thirdparty/arrow/src/arrow/config.h b/thirdparty/arrow/src/arrow/config.h
index 87e31cc456..d851f2d4cf 100644
--- a/thirdparty/arrow/src/arrow/config.h
+++ b/thirdparty/arrow/src/arrow/config.h
@@ -20,7 +20,7 @@
 #include <string>
 
 #include "arrow/status.h"
-#include "arrow/util/config.h"  // IWYU pragma: export
+//#include "arrow/util/config.h"  // IWYU pragma: export
 #include "arrow/util/optional.h"
 #include "arrow/util/visibility.h"
 
diff --git a/thirdparty/arrow/src/arrow/io/CMakeLists.txt b/thirdparty/arrow/src/arrow/io/CMakeLists.txt
index 1669a9ba6e..3034cb8fcc 100644
--- a/thirdparty/arrow/src/arrow/io/CMakeLists.txt
+++ b/thirdparty/arrow/src/arrow/io/CMakeLists.txt
@@ -18,6 +18,7 @@
 # ----------------------------------------------------------------------
 # arrow_io : Arrow IO interfaces
 
+#[[
 add_arrow_test(buffered_test PREFIX "arrow-io")
 add_arrow_test(compressed_test PREFIX "arrow-io")
 add_arrow_test(file_test PREFIX "arrow-io")
@@ -37,3 +38,4 @@ endif()
 
 # Headers: top level
 arrow_install_all_headers("arrow/io")
+]]
\ No newline at end of file
diff --git a/thirdparty/arrow/src/arrow/sparse_tensor.cc b/thirdparty/arrow/src/arrow/sparse_tensor.cc
index 7e48bb80f0..1f206303be 100644
--- a/thirdparty/arrow/src/arrow/sparse_tensor.cc
+++ b/thirdparty/arrow/src/arrow/sparse_tensor.cc
@@ -52,6 +52,7 @@ Status CheckSparseIndexMaximumValue(const std::vector<int64_t>& shape) {
   using c_index_value_type = typename IndexValueType::c_type;
   constexpr int64_t type_max =
       static_cast<int64_t>(std::numeric_limits<c_index_value_type>::max());
+  (void)type_max; // MSVC 17.2pre3 false positive
   auto greater_than_type_max = [&](int64_t x) { return x > type_max; };
   if (std::any_of(shape.begin(), shape.end(), greater_than_type_max)) {
     return Status::Invalid("The bit width of the index value type is too small");
diff --git a/thirdparty/arrow/src/arrow/type.cc b/thirdparty/arrow/src/arrow/type.cc
index df5f786e5f..d394bc52c4 100644
--- a/thirdparty/arrow/src/arrow/type.cc
+++ b/thirdparty/arrow/src/arrow/type.cc
@@ -1006,7 +1006,7 @@ struct FieldPathGetImpl {
     }
 
     int depth = 0;
-    const T* out;
+    const T* out = nullptr;
     for (int index : path->indices()) {
       if (children == nullptr) {
         return Status::NotImplemented("Get child data of non-struct array");
diff --git a/thirdparty/arrow/src/arrow/type.h b/thirdparty/arrow/src/arrow/type.h
index 030c81a9b8..3937b0d15a 100644
--- a/thirdparty/arrow/src/arrow/type.h
+++ b/thirdparty/arrow/src/arrow/type.h
@@ -720,9 +720,9 @@ class ARROW_EXPORT FixedSizeBinaryType : public FixedWidthType, public Parametri
 /// \brief Base type class for (fixed-size) decimal data
 class ARROW_EXPORT DecimalType : public FixedSizeBinaryType {
  public:
-  explicit DecimalType(Type::type type_id, int32_t byte_width, int32_t precision,
+  explicit DecimalType(Type::type id, int32_t byte_width, int32_t precision,
                        int32_t scale)
-      : FixedSizeBinaryType(byte_width, type_id), precision_(precision), scale_(scale) {}
+      : FixedSizeBinaryType(byte_width, id), precision_(precision), scale_(scale) {}
 
   /// Constructs concrete decimal types
   static Result<std::shared_ptr<DataType>> Make(Type::type type_id, int32_t precision,
diff --git a/thirdparty/arrow/src/arrow/util/bit_util.h b/thirdparty/arrow/src/arrow/util/bit_util.h
index 8583e10b22..401cce1ce5 100644
--- a/thirdparty/arrow/src/arrow/util/bit_util.h
+++ b/thirdparty/arrow/src/arrow/util/bit_util.h
@@ -67,7 +67,14 @@ static constexpr uint8_t kBytePopcount[] = {
     5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6,
     4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};
 
+#ifdef _WIN32
+static inline uint64_t PopCount(uint64_t bitmap) {
+    const auto bits_u32 = reinterpret_cast<uint32_t*>(&bitmap);
+    return ARROW_POPCOUNT32(*bits_u32) + ARROW_POPCOUNT32(*(bits_u32 + 1));
+}
+#else
 static inline uint64_t PopCount(uint64_t bitmap) { return ARROW_POPCOUNT64(bitmap); }
+#endif
 static inline uint32_t PopCount(uint32_t bitmap) { return ARROW_POPCOUNT32(bitmap); }
 
 //
@@ -195,6 +202,17 @@ static inline int CountLeadingZeros(uint32_t value) {
 #endif
 }
 
+#ifdef _WIN32
+static inline int CountLeadingZeros(uint64_t value) {
+    const auto bits_u32 = reinterpret_cast<uint32_t*>(&value);
+
+    auto zeros = CountLeadingZeros(*bits_u32);
+    if (zeros == 32) {
+        zeros += CountLeadingZeros(*(bits_u32 + 1));
+    }
+    return zeros;
+}
+#else
 static inline int CountLeadingZeros(uint64_t value) {
 #if defined(__clang__) || defined(__GNUC__)
   if (value == 0) return 64;
@@ -215,6 +233,7 @@ static inline int CountLeadingZeros(uint64_t value) {
   return 64 - bitpos;
 #endif
 }
+#endif
 
 static inline int CountTrailingZeros(uint32_t value) {
 #if defined(__clang__) || defined(__GNUC__)
@@ -241,6 +260,17 @@ static inline int CountTrailingZeros(uint32_t value) {
 #endif
 }
 
+#ifdef _WIN32
+static inline int CountTrailingZeros(uint64_t value) {
+    const auto bits_u32 = reinterpret_cast<uint32_t*>(&value);
+
+    auto zeros = CountTrailingZeros(*(bits_u32 + 1));
+    if (zeros == 32) {
+        zeros += CountTrailingZeros(*bits_u32);
+    }
+    return zeros;
+}
+#else
 static inline int CountTrailingZeros(uint64_t value) {
 #if defined(__clang__) || defined(__GNUC__)
   if (value == 0) return 64;
@@ -265,6 +295,7 @@ static inline int CountTrailingZeros(uint64_t value) {
   return bitpos;
 #endif
 }
+#endif
 
 // Returns the minimum number of bits needed to represent an unsigned value
 static inline int NumRequiredBits(uint64_t x) { return 64 - CountLeadingZeros(x); }
diff --git a/thirdparty/arrow/src/arrow/util/bitmap_generate.h b/thirdparty/arrow/src/arrow/util/bitmap_generate.h
index 5efc5d5a1d..6825bf8833 100644
--- a/thirdparty/arrow/src/arrow/util/bitmap_generate.h
+++ b/thirdparty/arrow/src/arrow/util/bitmap_generate.h
@@ -90,7 +90,8 @@ void GenerateBitsUnrolled(uint8_t* bitmap, int64_t start_offset, int64_t length,
     for (int i = 0; i < 8; ++i) {
       out_results[i] = g();
     }
-    *cur++ = (out_results[0] | out_results[1] << 1 | out_results[2] << 2 |
+    *cur++ = static_cast<uint8_t>(
+              out_results[0] | out_results[1] << 1 | out_results[2] << 2 |
               out_results[3] << 3 | out_results[4] << 4 | out_results[5] << 5 |
               out_results[6] << 6 | out_results[7] << 7);
   }
diff --git a/thirdparty/arrow/src/arrow/util/utf8.h b/thirdparty/arrow/src/arrow/util/utf8.h
index 655108b5a3..cb8264d7d7 100644
--- a/thirdparty/arrow/src/arrow/util/utf8.h
+++ b/thirdparty/arrow/src/arrow/util/utf8.h
@@ -23,7 +23,7 @@
 #include <memory>
 #include <string>
 
-#if defined(ARROW_HAVE_NEON) || defined(ARROW_HAVE_SSE4_2)
+#if 0 //defined(ARROW_HAVE_NEON) || defined(ARROW_HAVE_SSE4_2)
 #include <xsimd/xsimd.hpp>
 #endif
 
@@ -239,7 +239,7 @@ static inline bool ValidateAsciiSw(const uint8_t* data, int64_t len) {
   return orall < 0x80U;
 }
 
-#if defined(ARROW_HAVE_NEON) || defined(ARROW_HAVE_SSE4_2)
+#if 0 //defined(ARROW_HAVE_NEON) || defined(ARROW_HAVE_SSE4_2)
 static inline bool ValidateAsciiSimd(const uint8_t* data, int64_t len) {
   using simd_batch = xsimd::make_sized_batch_t<int8_t, 16>;
 
@@ -268,7 +268,7 @@ static inline bool ValidateAsciiSimd(const uint8_t* data, int64_t len) {
 #endif  // ARROW_HAVE_NEON || ARROW_HAVE_SSE4_2
 
 static inline bool ValidateAscii(const uint8_t* data, int64_t len) {
-#if defined(ARROW_HAVE_NEON) || defined(ARROW_HAVE_SSE4_2)
+#if 0 //defined(ARROW_HAVE_NEON) || defined(ARROW_HAVE_SSE4_2)
   return ValidateAsciiSimd(data, len);
 #else
   return ValidateAsciiSw(data, len);
diff --git a/thirdparty/arrow/src/arrow/util/variant.h b/thirdparty/arrow/src/arrow/util/variant.h
index 8bbce52517..ef52d72f7c 100644
--- a/thirdparty/arrow/src/arrow/util/variant.h
+++ b/thirdparty/arrow/src/arrow/util/variant.h
@@ -144,11 +144,11 @@ struct VariantImpl<Variant<T...>> : VariantStorage<T...> {
   void copy_to(...) const {}
 
   template <typename R, typename Visitor>
-  [[noreturn]] R visit_const(Visitor&& visitor) const {
+  [[noreturn]] R visit_const(Visitor&& /*visitor*/) const {
     std::terminate();
   }
   template <typename R, typename Visitor>
-  [[noreturn]] R visit_mutable(Visitor&& visitor) {
+  [[noreturn]] R visit_mutable(Visitor&& /*visitor*/) {
     std::terminate();
   }
 };
@@ -436,7 +436,7 @@ auto operator!=(const Variant<T...>& l, const Variant<T...>& r) -> decltype(l ==
 /// \brief Return whether the variant holds a value of the given type
 template <typename U, typename... T>
 bool holds_alternative(const Variant<T...>& v) {
-  return v.template get<U>();
+  return v.template get<U>() != nullptr;
 }
 
 }  // namespace util
-- 
2.29.2.windows.1

